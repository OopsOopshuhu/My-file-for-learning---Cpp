# 这是一篇基础以外的数据结构整理文件，如B树，时间轮，跳表，LSM-Tree等中间件

## 1. B树---用来存储磁盘数据---中序遍历有序
### B+树
1. 节点大小---磁盘页(4k)的整数倍
2. 多路---降低层高，降低磁盘访问次数(更低的磁盘IO)
3. 叶子节点在同一层，非叶子节点只存放索引
4. 叶子节点互连(范围查询的时候非常有用，只需要确定一个边界，然后就可以顺着叶子往下找，不需要再从根节点出发，从而减少磁盘IO的访问)
>B, B+ 区别：
**B树节点既存储数据信息，又存储索引信息**。在非叶子节点可以将数据返回
**B+树**非叶子节点只有索引信息，可以存储更多的索引数据，从而有效降低层高即有更低的磁盘IO，**搜索效率更高**。
B+树只有到叶子节点才可以获取数据，提供稳定的搜索时间复杂度(数据都在叶子节点，效果明显)
查找数据的时候都需要通过一次磁盘IO把数据读到内存。因为存放相关信息，然后在内存确定下一步该往哪走，再次通过磁盘IO继续读取，直到找到需求页。因为B+树非叶子节点只存放索引，所以**B+树加载到内存的无效数据更少！**
**通常 内存中使用B树，磁盘中使用B+树**，**如etcd**。而**MySQL**和**mongodb**都是**B+树**

>**etcd:** 提供**强一致，高可用的数据访问服务**---分布式很关键的一环
**强一致：** 往一个节点里写数据，会同步半数以上，哪怕这个节点宕机了，拿到的数据也是最新的数据
**高可用：** 宕机之后依然提供可用服务
**内存中使用B树，磁盘中使用B+树原因：**
B和B+树都映射磁盘页，当内存数据刷盘刷到磁盘中时，由于数据块是一样的，去刷到B+树的时候更方便，所以内存使用B树。etcd只会存储少量重要的信息，主要解决**读**的速度快的问题。

![](2023-02-15-10-31-53.png)

>补充：
MySQL当中，数据是结构化存储，存储的都是一行行记录，这些记录都会存储在聚集索引B+树(叶子节点记录行信息)当中，例如主键索引就是聚集索引B+树，其他所有索引都是辅助索引B+树(叶子节点 索引+bookmark(id))
如果要通过辅助索引去找某一行数据，通过辅助索引在通过聚集索引找到

>索引优化：最左匹配规则(B+树有序，针对组合索引，如根据(age,name)进行排序，那么key用来排序的字段就是这两个字段。先比较age，当遇到年龄相等的时候，去比较name。其实就是按照从左到右规则依次匹配)，索引覆盖(select具体数据的时候，这个数据恰好在辅助索引B+树当中就可以获取所有的数据，而不需要通过辅助索引再回表查询聚集索引B+树)
索引失效：到底有没有走索引还要看他的执行计划explain。

>事务：服务器跟数据库之间，需要多条语句来执行业务逻辑，不想被其他请求所干扰。事务就是把这个多条语句作为一个整体去执行，即原子性。事务机制和B+树的关系：因为必须要使用锁，MySQL支持的是行锁。遍历到一个记录，在记录上加锁。实际工作当中，会遇到读异常，死锁问题(加锁顺序出现问题，即忽略了B+树，因为B+树有序，加锁顺序就按照B+树排序顺序加锁，所以只要调整加锁顺序即可)。

## 2. 时间轮(linux内核定时器、kafka分布式消息队列、skynet、netty-java开发)
**时间轮**也是一种层次结构，根据时钟表盘来的。**用来存储海量定时任务，用在多线程环境下定时器设计**

之前都是通过**红黑树、最小堆、跳表来实现定时器**，都是**按照触发时间顺序进行组织**的---找最小值->最近触发的定时任务
而按照时间顺序，红黑树每次都要平衡左右子树的高度，最小堆要把最小元素挪到上面，跳表也是(log2n二分查找的时间复杂度)

**时间轮是按照执行顺序进行组织**的o(1)，**执行顺序是按照指针移动的方式**

时分秒时间分三个层级。三个指针数组，三个指针同时触发，所以通过链表连接
![](2023-02-15-10-54-02.png)
只关注最近20秒要执行的任务，其他层级的任务都是进行稀疏存储，减少内存开销

## 3. 跳表(redis kv v->zset 有序集合 score(排序) member(确定唯一)、leveldb、rocksdb嵌入式存储引擎，可以替换innodb)
跳表通常也称为多层级有序链表---随机性的数据结构(redis认为>256个节点才能达到log2n)，随机的意思是插入节点时随机层数
有序链表怎么做到log2n？
![](2023-02-15-11-55-28.png)
每次查找元素从最上层开始查找

## 4. LSM-tree(rocksdb核心结构)
MemTable就是跳表
![](2023-02-15-12-09-27.png)