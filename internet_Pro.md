## 网络编程知识整理
![](2023-03-01-08-59-13.png)
* 应用层：提供接口，可以访问网络服务。进程通信也要遵守一些协议：HTTP，FTP，DNS
* 表示层：数据格式转换，解密加密，编码解码。如URL加密，口令加密，图片编解码，**Telnet,SNMP**
* 会话层：管理session，如使用校验点实现数据同步，恢复通信，服务器验证用户登陆、断点续传，SMTP、DNS（域名解析）
* 传输层：接受上层数据，并分段 **（segment/datagram）**，交给网络层， **TCP/UDP** 保证数据有效对端，端口 **Socket**，要处理端到端的 **差错控制** 和 **** 问题。端到端基础上细分进程到进程
* 网络层：控制子网运行，如逻辑编址，分组传输，路由选择。**IP协议，路由选择协议，ARP协议**。端到端的**package**传输(尽力而为)。**路由器，交换机，防火墙**，**拥塞控制**
> IP协议：路由表做转发处理
> 路由协议：路由实体间交换路由信息，到哪个子网，几跳多少延迟，什么代价。路由选择算法选出路由表
> 更有弹性的工作方式：SDN---软件定义网络
> 数据平面（交换机）：多字段匹配流表，根据流表行为冻住分组，转发、泛洪、block，改字段
> 控制平面（网络OS）：网络应用算出流表（源IP/目标IP等多字段），南向接口发给交换机
* 数据链路层：物理寻址 **（MAC）**，**ARP协议**，**流量控制**，数据检错重发，**frame**传输，如**网卡**，网桥，二层交换机
* 物理层：传输介质。**bit**流传输
### 传输层
* PDU---协议数据单元，报文格式统称（每一层的数据单元都不一样）
* TCP---面向连接的通信方式，要打招呼，底层的协议栈为进程通信准备资源、做好标记，准备缓冲区，控制变量置位，超时定时器设置等。是一种可靠的传输，可以进行流量和拥塞控制
* 网络核心数据**分组交换**：链路之间每一跳使用带宽的全部，存储转发存储转发。代价排队延迟和数据丢失，本质是时分多路复用（划时间片）
* 丢包---到达速率>链路输出速率。路由器缓存用完了，丢弃。或者TTL减到0
* 丢包重传---路由器重传、源主机重传
* 套接字就是socket API的SAP（服务访问点）---决定数据报文到底属于哪个用户进程的
* SDU（Server data unit），上层交给下层，加一些控制信息（ICI---interface control information），形成本层的PDU
* 传输层向应用层提供的服务---数据丢失率，延迟，吞吐，安全性（SSL）
* Web是一种应用，HTTP是支持应用的协议。web网页就是一个对象，任何对象都可以通过URL访问
* HTTP协议：超文本传输协议。连接建立之后，HTTP客户端与Web服务器交换HTTP报文
* cookies维护历史状态信息，也可以使用Web缓存（redis算吗）
* UDP数据报格式：
  1. 源端口号、目标端口号
  2. 长度（包括报文）
  3. EDC（差错检测码，校验和，如果出错就扔掉）
  4. 报文
* RDT（可靠数据传输原理）
  传输层要向上层提供可靠的服务，但是依赖的UDP并不可靠。上层调用**rdt_send**。数据交付给下方**make_pkt**。然后借助发送方可靠传输实体往下发**udp_send**。如果下方的chennel也不可靠，对方**rdt_rcv**这个packet，**extract** data。通过**deliver_data**交给接收方进程

* TCP提供可靠的数据传输
  * 随机标志位---建立连接
  * 序号机制---保证按序完整到达
  * checksum---CRC校验
  * 超时重传---自适应超时定时器
  * 快速重传---发送方收到某些段的三个冗余确认
  * slidewinow---流量控制(piggybacking---反馈buffer剩余空间)
  * 拥塞控制---拥塞窗+控制策略
* 差错控制
  1. stop-wait协议：（检验和检测，差错控制编码，NAKfree, 分组丢失---超时重传）
  2. pipeline协议（瓶颈在链路带宽）：
   * GBN(go back n)
   * SR(selective repeat)
  3. 通用---slide window协议
   > 发送缓冲区：存放已发送没确认的分组，重传时可用
   * 超时重传
     * RTO(retransmisssion timeout)：每次重传RTO是前一次重传间隔的两倍，次数上限停止重传
     * 发送窗：限制发送方可以发送的数据大小，窗的大小由接收端告知
     * 接收窗：标记可以接收的数据大小
* TCP报文段结构
  * 16bit/源端口+16bit/目标端口
  * 32/bit序号---每发送数据，序号=ISN(随机初始值)+offset，防止乱序
  * 32/bit确认号---累积确认
  * 6/bit标志位
  1）RST---要求重建连接（复位报文段）
  2）SYN---请求建立连接（连接报文段）
  3）FIN---关闭连接（关闭报文段）
  4) ECE---IP首部ECN为1时，将TCP首部ECE置1,拥塞窗口减小
  5) URG---紧急数据处理
  6) ACK
  7) PSH---为1,数据上传应用协议，为0,数据缓存
  * 16bit/窗口---告知发送方缓冲区海南呢个接收多少字节数据，解决**流量控制**
  * 16bit/checksum---接收端CRC检验报文段有无损坏
* 2次握手的半连接（虚假连接）
  连接请求超时，收到确认前再次连接请求。收到第一个连接请求确认并发送数据，数据确认超时，再次发送数据。就是请求和数据都超时重发，服务器新连接拿到了旧数据
* 三次握手
  1. 连接请求---第一次握手
    * SYN = 1
    * sequeneceNum = x --- 初始序列号
  2. 服务器发送连接确认---第二次握手 
    * SYN = 1
    * ACK = 1
    * ACKnum = x+1 
    * sequeneceNum = y
  3. 确认初始序号---发出第三次握手，和数据在一起
    * ACK = 1
    * ACKnum = y+1
  结果：ESTABLISH
  > 如果第三次握手不成功，给服务器一个拒绝信息，取消半连接
  如果第三次握手发送的数据滞留在了网络里，连接取消之后流到服务器，不会有什么影响，直接扔掉数据
  如果相同端口再次建立连接，老数据刚好流入，序号不一致，序号不在我的范围，直接扔掉
* 四次挥手---连接释放
  两个方向单独拆除
  1. 客户端发送FIN，SEQ = x
  2. 服务器ACK，ACKnum = x+1
  3. 服务器发送FIN SEQ = y
  4. 客户端ACK, ACKnum = y+1
* TCP的连接状态
  * closed
  * listen
  * syn_send
  * syn_recv
  * establish
  * fin_wait_1：等待对方fin
  * close_wait：如果关闭之前还有包要给客户端，那就等一下
  * fin_wait_2：半连接状态，接收到服务器的ACK，还没收到fin
  * last_ACK：服务器最后的fin包，等待客户端ACK
  * time_wait：收到服务器fin包，立即返回ACK做最后的确认，之后的2MSL时间
  > 如果客户端直接进入closed状态，服务器还没收到最后一次ACK呢，服务器会再超时之后重传fin包，客户端并不会有回应，没收到ACK而是收到RST。所以time_wait是防止最后一次握手数据没有到达而触发重传fin准备的。所以服务器要收到ACK客户端才能closed，不然会一直重传fin
* 拥塞控制---太多数据，超过网络处理能力
  1. 表现：
      * 分组丢失（缓冲区溢出）
      * 大延迟，流量强度 = 1,而且越超时，越重发
  2. 手段：
      * 端到端控制
      * 网络辅助控制
  3. 检测拥塞
      * 超时ci
      * 三个冗余ACK
  4. congwin---拥塞窗，控制发送端的发送速率
   在对方未确认的情况下可以向网络注入多少字节，然后除以往返延迟得到单位时间可以注入的字节数。
  5. 联合控制 sendWin = min(Congwin, sendWin)
  6. 拥塞控制策略
       1. 慢启动
  每一个RTT，congwin加倍。每收到一个ACK，congwin+1MSS,直到达到阈值ssthresh或发生丢包
       1. 拥塞避免
  为了避免网络过载，congwin增长变为线性，每一个RTT，congwin+1MSS
       1. 快速重传
       2. 快速恢复
  执行完快速重传后，Threshold = congwin/2，congwin = Threshold+3，继续拥塞避免算法
      * 乘性减
  丢失发生后congwin降为1,congwin/2作为阈值，进入慢启动，倍增到congwin/2
      * 线性增
  当congwin>Threshold，一个RTT如果没有丢失事件，将congwin+1MSS。进入拥塞避免阶段，窗口线性增长
### 网络层
* 数据平面SDN：多字段+流表
* 控制平面SDN：远程服务器网络应用实现
* 路由器
  * 路由：选择算法生成路由表，协议（RIP，OSPF，BGP）
  * 转发：IP协议对到来的路由表分组转发，匹配目标IP
  * SDN：网络应用拿到流表，南向结构交给SDN交换机，按照流表对到来的分组做多字段匹配，做多种动作
  * 缓冲区queue
* 路由选择算法---为所有路由器找到并使用sink tree
  * 输入：网络拓扑，边的代价，源
  * 输出：source到所有目标的最短路径 
* 最优化原则（optimality principle）
  汇集树(sink tree)---此节点到所有其他节点的最优路径形成的树(最终形成路由表)
  * 链路状态算法link state routing (得到整个网络拓扑，再用dijstra算最短路径)。真实情况因为流量代价的浮动所以会出现振荡
  * distance vector（dp算法）。本节点到邻居的代价+邻居到目标的代价和的最小值
* 路由选择协议（内部网关协议）
  * RIP通告（基于DV）：邻居之间定期交换通告报文
  * OSPF(基于LS)：每一个节点拥有本地区的拓扑信息
    1. 区域边界路由器：“汇总，聚集”到自己区域内网络的距离，向其他边界路由器通告
    2. 骨干路由器：仅仅在骨干区域OSPF路由
    3. 边界路由器：连接到其他AS's
  * BGP(ISP间的)
    1. eBGP：相邻ASes获得子网可达信息
    2. iBGP：子网可达信息传遍AS内部所有路由器
    3. 根据子网可达信息和策略来决定到达子网的路径
   1）本地偏好
   2）最短AS-PATH：AS跳数
   3）最近NEXT-HOP路由：热土豆路由
   4）BGP标识
* ARP协议：地址解析协议---用于局域网通信，寻找MAC地址
### 链路层和局域网
* 差错检测：
  * EDC：差错检测和纠正位
  * CRC---循环冗余校验
    1. 异或运算（模2运算）
    2. 位串的两种表示（1011,生成多项式）
    3. 生成多项式（r次方的bit序列）
    4. 约定：EDC（r位），发送方数据位附上r位冗余位，使得正好能被多项式整除，能整除就没错
* MAP多点访问协议：分布式算法，决定节点如何使用共享信道，决定谁，什么时候可以使用这个信道发送
* MAC（介质访问控制协议）：多点发送，会出现电磁波冲突
### 面试
* 区分流量控制和拥塞控制
  * 流量控制是双方协商，拥塞控制涉及通信链路全局（控制流量强度）
  * 流量控制双方窗口，拥塞窗是自适应调整的
  * 实际最终的sendWin = min(Congwin, sendvWin)
* TCP粘包、拆包发生原因
  * 数据大于TCP发送缓冲区的大小，拆包
  * 待发送数据大于MSS，拆包
  * 小于TCP发送缓冲区的大小，多次写入缓冲区的数据一次发送，粘包
  * 接收端没有及时读取缓冲区数据，粘包
* 解决方式
  TCP是基于字节流的，所以只能通过上层协议栈解决
  * 消息定长：数据包长度固定，不够补0,接收端就懂拆分了
  * 设置消息边界：服务端根据边界分离消息内容，在包尾增加换行符分割
  * 将消息分为消息头和消息体：消息头包含消息总长度的字段
* 提高网络利用率
  1. Nagle算法---发送端还有一丢丢数据要发，则延迟发送，再来请求一起发，合并成一个TCP段
  2. 延迟确认应答---接收方并不马上发送ACK，攒着一起发
  3. 在一个TCP包中既给数据也给应答